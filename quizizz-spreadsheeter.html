<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quizizz CSV Generator</title>
    <link rel="icon" type="image/png" href="https://sirpoji007.github.io/microsites/spreadsheeter.png">
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Quizizz CSV Generator">
    <meta property="og:description" content="Upload your PDF material and convert it into a Quizizz-compatible CSV file!">
    <meta property="og:image" content="https://sirpoji007.github.io/microsites/spreadsheeter.png">
    <meta property="og:type" content="website">
    <!-- End Open Graph Meta Tags -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js library for extracting PDF text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        input[type="file"] {
            display: none;
        }
        .dark {
            color-scheme: dark;
        }
        .dark .bg-white {
            background-color: #181818;
        }
        .dark .text-gray-800 {
            color: #e0e0e0;
        }
        .dark .text-gray-600, .dark .text-gray-500 {
            color: #a0a0a0;
        }
        .dark .border-gray-300 {
            border-color: #404040;
        }
        .dark .text-gray-700 {
            color: #d0d0d0;
        }
        .dark .bg-green-100 {
            background-color: rgba(74, 222, 128, 0.2);
        }
        .dark .border-green-400 {
            border-color: rgba(74, 222, 128, 0.5);
        }
        .dark .text-green-700 {
            color: rgb(74, 222, 128);
        }
        .dark .bg-red-100 {
            background-color: rgba(248, 113, 113, 0.2);
        }
        .dark .border-red-400 {
            border-color: rgba(248, 113, 113, 0.5);
        }
        .dark .text-red-700 {
            color: rgb(248, 113, 113);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
        
        // Set PDF.js worker path
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-400 via-pink-500 to-red-500 flex flex-col items-center justify-center p-4">

    <div class="bg-white bg-opacity-90 rounded-xl shadow-2xl p-8 w-full max-w-2xl text-center">

        <div class="flex justify-center mb-6">
            <div class="bg-blue-500 p-4 rounded-full shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                    <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="16" y1="13" x2="8" y2="13"/>
                    <line x1="16" y1="17" x2="8" y2="17"/>
                    <line x1="10" y1="9" x2="8" y2="9"/>
                </svg>
            </div>
        </div>

        <h1 class="text-3xl font-bold text-gray-800 mb-4">Quizizz Question Generator</h1>
        <p class="text-gray-600 mb-8">Upload your PDF material and convert it into a Quizizz-compatible CSV file!</p>

        <div id="upload-area" class="mb-6 border-2 border-dashed border-gray-300 rounded-lg p-6 hover:border-blue-500 transition duration-300 ease-in-out cursor-pointer">
            <input type="file" accept=".pdf" id="pdfUpload">
            <label for="pdfUpload" class="flex flex-col items-center justify-center cursor-pointer">
                <svg id="upload-icon-default" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-400 mb-3">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                <svg id="upload-icon-selected" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-500 mb-3 hidden">
                    <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="16" y1="13" x2="8" y2="13"/>
                    <line x1="16" y1="17" x2="8" y2="17"/>
                    <line x1="10" y1="9" x2="8" y2="9"/>
                </svg>

                <span id="upload-text-default" class="text-lg font-semibold text-gray-700">Drag & Drop or Click to Upload PDF</span>
                <span id="upload-text-selected" class="text-lg font-semibold text-green-700 hidden"></span>
                <span class="text-sm text-gray-500 mt-1">(Max file size: 10MB)</span>
            </label>
        </div>

        <div id="question-settings" class="mb-6 hidden">
            <div class="flex flex-col gap-4">
                <div class="border rounded-md p-4 bg-gray-50 dark:bg-gray-800">
                    <h3 class="text-left text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Question Settings</h3>
                    
                    <div class="mb-3">
                        <label for="num-mc-questions" class="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">Number of Multiple Choice Questions:</label>
                        <input type="number" id="num-mc-questions" min="0" max="50" value="10" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-base focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    
                    <div class="mb-3">
                        <label for="num-open-questions" class="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">Number of Open-Ended Questions:</label>
                        <input type="number" id="num-open-questions" min="0" max="10" value="2" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-base focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>

                    <div class="mb-3">
                        <label for="mc-points" class="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">Points for Multiple Choice Questions:</label>
                        <input type="number" id="mc-points" min="1" max="20" value="1" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-base focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    
                    <div class="mb-3">
                        <label for="open-points" class="block text-sm font-medium text-gray-700 dark:text-gray-300 text-left mb-1">Points for Open-Ended Questions:</label>
                        <input type="number" id="open-points" min="1" max="20" value="5" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-base focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
            </div>
        </div>

        <div id="error-message" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-6 items-center justify-center hidden" role="alert">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 mr-2 inline-block">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            <span id="error-text" class="block sm:inline"></span>
        </div>

        <button id="process-button" class="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-white bg-gray-400 cursor-not-allowed md:py-4 md:text-lg md:px-10 transition duration-300 ease-in-out" disabled>
            <svg id="button-icon-send" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-3">
                <line x1="22" y1="2" x2="11" y2="13"/>
                <polygon points="22 2 15 22 11 13 2 9 22 2"/>
            </svg>
            <svg id="button-icon-loader" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin mr-3 hidden">
                <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
            </svg>
            <span id="button-text">Generate Questions</span>
        </button>

        <div id="processing-status" class="mt-4 hidden">
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="status-text" class="text-sm text-gray-600 mt-1">Preparing to process your PDF...</p>
        </div>

        <div id="preview-container" class="mt-6 hidden">
            <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2 text-left">Preview (first 3 rows):</h3>
            <div class="overflow-x-auto bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
                <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                    <thead class="bg-gray-50 dark:bg-gray-900">
                        <tr id="preview-header">
                            <!-- Headers will be inserted here -->
                        </tr>
                    </thead>
                    <tbody id="preview-body" class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                        <!-- Rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>

        <div id="output-area" class="mt-8 p-6 bg-green-100 border border-green-400 text-green-700 rounded-lg flex flex-col items-center justify-center hidden">
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-600 mb-4">
                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
                <line x1="10" y1="9" x2="8" y2="9"/>
            </svg>
            <p class="text-lg font-semibold mb-4">CSV Generation Complete!</p>
            <p id="csv-info" class="mb-4"></p>
            <a id="download-link" href="#" download="quizizz_questions.csv" class="flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-300 ease-in-out">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-3">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                Download CSV
            </a>
            <div class="mt-4 text-left">
                <p class="text-sm mb-2">Next steps:</p>
                <ol class="list-decimal list-inside text-sm">
                    <li class="mb-1">Download the CSV file</li>
                    <li class="mb-1">In Quizizz, click "Create" → "Quiz"</li>
                    <li class="mb-1">Click "Import from spreadsheet" and upload this CSV</li>
                    <li class="mb-1">Review and edit your questions as needed</li>
                </ol>
            </div>
        </div>

        <p class="text-xs text-gray-500 mt-8">
            Note: This tool extracts content from your PDF and formats it according to the Quizizz template format. You may need to review and refine the questions before using them in a quiz.
        </p>

    </div>
    
    <footer class="text-center py-4 mt-auto text-sm text-white">
        SirPoji 2025 @ All rights reserved
    </footer>

    <script>
        // Get references to DOM elements
        const fileInput = document.getElementById('pdfUpload');
        const uploadAreaLabel = document.querySelector('#upload-area label');
        const uploadIconDefault = document.getElementById('upload-icon-default');
        const uploadIconSelected = document.getElementById('upload-icon-selected');
        const uploadTextDefault = document.getElementById('upload-text-default');
        const uploadTextSelected = document.getElementById('upload-text-selected');
        const questionSettings = document.getElementById('question-settings');
        const numMCQuestionsInput = document.getElementById('num-mc-questions');
        const numOpenQuestionsInput = document.getElementById('num-open-questions');
        const mcPointsInput = document.getElementById('mc-points');
        const openPointsInput = document.getElementById('open-points');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const processButton = document.getElementById('process-button');
        const buttonIconSend = document.getElementById('button-icon-send');
        const buttonIconLoader = document.getElementById('button-icon-loader');
        const buttonText = document.getElementById('button-text');
        const processingStatus = document.getElementById('processing-status');
        const progressBar = document.getElementById('progress-bar');
        const statusText = document.getElementById('status-text');
        const previewContainer = document.getElementById('preview-container');
        const previewHeader = document.getElementById('preview-header');
        const previewBody = document.getElementById('preview-body');
        const outputArea = document.getElementById('output-area');
        const csvInfo = document.getElementById('csv-info');
        const downloadLink = document.getElementById('download-link');

        let selectedFile = null;
        let extractedText = '';
        let extractedPages = [];
        let csvData = [];
        const csvHeaders = ["Question Type", "Question", "Option A", "Option B", "Option C", "Option D", "Correct Answer", "Points"];
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

        const DOMAIN_KEYWORDS = {
            finance: ["money", "bank", "loan", "interest", "credit", "debit", "invest", "market", "stock", "bond", "asset", "liability", "capital", "deposit", "finance", "fiscal", "fund", "portfolio", "security", "share", "yield", "dividend", "equity"],
            science: ["experiment", "hypothesis", "theory", "research", "laboratory", "data", "evidence", "observation", "molecule", "atom", "cell", "element", "compound", "reaction", "energy", "ecosystem", "species", "organism"],
            history: ["century", "decade", "era", "period", "ancient", "medieval", "modern", "revolution", "war", "empire", "kingdom", "dynasty", "treaty", "monarch", "president", "government", "civilization", "culture"],
            literature: ["novel", "poem", "essay", "author", "character", "plot", "theme", "setting", "dialogue", "narrative", "genre", "literary", "fiction", "nonfiction", "prose", "verse", "metaphor", "symbol"],
            technology: ["computer", "software", "hardware", "internet", "digital", "network", "system", "algorithm", "database", "program", "code", "application", "device", "innovation", "technology"]
        };

        // Handle file selection
        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) {
                // If user cancels file selection after having one, reset to initial state
                if (selectedFile) resetFileInput();
                return;
            }
            if (file.type !== 'application/pdf') {
                showError('Please select a valid PDF file.');
                resetFileInput();
                return;
            }
            if (file.size > MAX_FILE_SIZE) {
                showError(`File is too large. Maximum size is ${MAX_FILE_SIZE / (1024 * 1024)}MB.`);
                resetFileInput();
                return;
            }

            selectedFile = file;
            uploadIconDefault.classList.add('hidden');
            uploadIconSelected.classList.remove('hidden');
            uploadTextDefault.classList.add('hidden');
            uploadTextSelected.classList.remove('hidden');
            uploadTextSelected.textContent = file.name;

            errorMessage.classList.add('hidden');
            outputArea.classList.add('hidden');
            previewContainer.classList.add('hidden');
            if (downloadLink) {
                downloadLink.href = '#';
                downloadLink.removeAttribute('download');
            }
            csvData = []; // Clear previous data

            questionSettings.classList.remove('hidden');
            setProcessingState(false); // Enables process button if file is selected
        });

        // Handle Process Button Click
        processButton.addEventListener('click', async function() {
            if (!selectedFile) {
                showError('Please select a PDF file first.');
                return;
            }

            // Reset UI elements related to previous output/errors
            outputArea.classList.add('hidden');
            previewContainer.classList.add('hidden');
            if (downloadLink) {
                downloadLink.href = '#';
                downloadLink.removeAttribute('download');
            }
            errorMessage.classList.add('hidden');

            setProcessingState(true);
            updateStatus("Reading PDF file...", 10);

            try {
                const result = await extractContentFromPDF(selectedFile);
                extractedText = result.text;
                extractedPages = result.pages;

                if (!extractedText || extractedText.trim().length === 0) {
                    throw new Error("Could not extract text from PDF. The file might be empty, corrupted, or password-protected.");
                }

                updateStatus("Analyzing content and generating questions...", 50);

                const numMCQuestions = parseInt(numMCQuestionsInput.value);
                const numOpenQuestions = parseInt(numOpenQuestionsInput.value);
                const mcPoints = parseInt(mcPointsInput.value);
                const openPoints = parseInt(openPointsInput.value);

                generateQuestions(extractedText, extractedPages, numMCQuestions, numOpenQuestions, mcPoints, openPoints);

                updateStatus("Formatting CSV data...", 80);

                const csvContent = generateCSVContent(csvData, csvHeaders, true);
                if (!csvContent && csvData.length > 0) {
                    console.warn("CSV content generation resulted in an empty string, but csvData was not empty. This might indicate an issue in generateCSVContent or escapeCSV function.");
                }


                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);

                downloadLink.href = url;
                downloadLink.download = `quizizz_questions_${new Date().toISOString().slice(0,10)}.csv`;

                const mcCount = csvData.filter(row => row[0] === "Multiple Choice").length;
                const openCount = csvData.filter(row => row[0] === "Open Ended").length;
                csvInfo.textContent = `Successfully created ${mcCount} multiple choice and ${openCount} open-ended questions.`;

                updatePreview(csvData, csvHeaders);
                previewContainer.classList.remove('hidden');
                outputArea.classList.remove('hidden');

                updateStatus("Complete!", 100);
                // Keep button active for re-generation, reset icons/text
                buttonIconSend.classList.remove('hidden');
                buttonIconLoader.classList.add('hidden');
                buttonText.textContent = 'Generate Questions';
                processButton.disabled = false; // Explicitly enable after success
                // The processingStatus bar will show "Complete!" until the next action.

            } catch (error) {
                console.error("Error during processing:", error); // Log the full error to console
                showError(error.message || "An error occurred during processing. Please try again.");
                setProcessingState(false); // This will reset button and hide progress bar
                updateStatus("Error occurred.", 0); // Explicitly set status text for error
            }
        });

        async function extractContentFromPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let fullText = '';
                let pages = [];
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    updateStatus(`Extracting text from page ${i} of ${pdf.numPages}...`, 10 + (i / pdf.numPages * 30));
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    const pageText = content.items.map(item => item.str).join(' ');
                    
                    fullText += pageText + '\n\n';
                    pages.push({
                        pageNum: i,
                        text: pageText
                    });
                }
                
                return {
                    text: fullText,
                    pages: pages
                };
            } catch (error) {
                console.error("PDF extraction error:", error);
                throw new Error("Failed to extract text from PDF. The file might be corrupted or password-protected.");
            }
        }

        function generateQuestions(text, pages, numMCQuestions, numOpenQuestions, mcPoints, openPoints) {
            csvData = [];
            const domain = detectContentDomain(text);
            if (numMCQuestions > 0) {
                generateMultipleChoiceQuestions(text, pages, numMCQuestions, mcPoints, domain);
            }
            if (numOpenQuestions > 0) {
                generateOpenEndedQuestions(text, pages, numOpenQuestions, openPoints, domain);
            }
            return csvData;
        }

        function detectContentDomain(text) {
            const textLower = text.toLowerCase();
            let domainCounts = {};
            for (const [domain, keywords] of Object.entries(DOMAIN_KEYWORDS)) {
                domainCounts[domain] = 0;
                keywords.forEach(keyword => {
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    const matches = textLower.match(regex);
                    if (matches) {
                        domainCounts[domain] += matches.length;
                    }
                });
            }
            let maxCount = 0;
            let detectedDomain = 'general';
            for (const [domain, count] of Object.entries(domainCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    detectedDomain = domain;
                }
            }
            return detectedDomain;
        }

        function generateMultipleChoiceQuestions(text, pages, numQuestions, points, domain) {
            const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 30);
            const keyConcepts = extractKeyConcepts(text, domain);
            const conceptQuestions = generateConceptBasedQuestions(keyConcepts, domain, Math.floor(numQuestions * 0.7));
            const contentQuestions = generateContentBasedQuestions(paragraphs, pages, Math.max(0, numQuestions - conceptQuestions.length)); 
            
            conceptQuestions.concat(contentQuestions).forEach(q => {
                if (q && q.options && q.options.length === 4 && q.question && q.answer) { 
                    csvData.push([
                        "Multiple Choice",
                        q.question,
                        q.options[0],
                        q.options[1],
                        q.options[2],
                        q.options[3],
                        q.answer, 
                        points.toString()
                    ]);
                } else {
                    console.warn("Skipping malformed MC question:", q);
                }
            });
        }

        function generateOpenEndedQuestions(text, pages, numQuestions, points, domain) {
            const topics = extractTopics(text, domain);
            for (let i = 0; i < numQuestions; i++) {
                if (i < topics.length && topics[i]) {
                    const question = generateOpenQuestion(topics[i], domain);
                     if(question) {
                        csvData.push([
                            "Open Ended",
                            question, "", "", "", "", "", points.toString()
                        ]);
                    } else {
                        console.warn("Skipping malformed Open question for topic:", topics[i]);
                    }
                } else if (topics.length === 0 && i === 0 && numQuestions > 0) { 
                    csvData.push([
                        "Open Ended",
                        `Summarize the main points of the provided document. (Page 1)`, "", "", "", "", "", points.toString()
                    ]);
                    break; 
                }
            }
        }

        function extractKeyConcepts(text, domain) { 
            const concepts = [];
            if (domain === 'finance') {
                const financialTerms = [
                    "money market", "capital market", "interest rate", "inflation", "exchange rate",
                    "financial instrument", "security", "stock", "bond", "derivative",
                    "bank", "financial institution", "central bank", "commercial bank",
                    "loan", "credit", "deposit", "investment", "portfolio", "risk",
                    "return", "yield", "dividend", "equity", "debt", "asset", "liability"
                ];
                financialTerms.forEach(term => {
                    const regex = new RegExp(`${term}[s]?(?:\\s+(?:is|are|refers to|means|can be defined as)\\s+[^.]+\\.)|(?:[^.]+\\s+(?:is|are|called)\\s+(?:(?:the|a|an)\\s+)?${term}[s]?\\.)`, 'gi');
                    const matches = text.match(regex);
                    if (matches) {
                        matches.forEach(match => {
                            if (match.length < 300) concepts.push({ term: term, description: match.trim() });
                        });
                    }
                });
            } else if (domain === 'science') {
                const regex = /([A-Z][a-z]+(?:\s+[a-z]+){0,3})\s+(?:is|are|refers to|means|can be defined as)\s+([^.]+)\./g;
                let match;
                while ((match = regex.exec(text)) !== null) {
                    if (match[0].length < 300) concepts.push({ term: match[1], description: match[0].trim() });
                }
            } else {
                const regex = /([A-Z][a-z]+(?:\s+[a-z]+){0,3})\s+(?:is|are|refers to|means|can be defined as|represents|consists of)\s+([^.]+)\./g;
                let match;
                while ((match = regex.exec(text)) !== null) {
                     if (match[0].length < 300) concepts.push({ term: match[1], description: match[0].trim() });
                }
            }
            if (concepts.length < 10) {
                const domainWords = DOMAIN_KEYWORDS[domain] || [];
                const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
                if (sentences) {
                    sentences.forEach(sentence => {
                        if (sentence.length > 30 && sentence.length < 200) {
                            const containsKeywords = domainWords.some(word => sentence.toLowerCase().includes(word));
                            if (containsKeywords) {
                                const words = sentence.split(' ');
                                let term = words.slice(0, 3).join(' ');
                                concepts.push({ term: term, description: sentence.trim() });
                            }
                        }
                    });
                }
            }
            return [...new Map(concepts.map(item => [item.description, item])).values()].slice(0, 50);
        }
        function extractTopics(text, domain) { 
            const topics = [];
            const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 50);
            paragraphs.forEach(paragraph => {
                const firstSentence = paragraph.match(/^[^.!?]+[.!?]+/);
                if (firstSentence) {
                    const sentence = firstSentence[0].trim();
                    const domainWords = DOMAIN_KEYWORDS[domain] || [];
                    const containsKeywords = domainWords.some(word => sentence.toLowerCase().includes(word));
                    if (containsKeywords && sentence.length > 30 && sentence.length < 250) { // Limit sentence length
                        topics.push({ topic: sentence, content: paragraph });
                    }
                }
            });
            if (topics.length < 5 && paragraphs.length > 0) {
                for (let i = 0; i < Math.min(paragraphs.length, 10); i++) {
                    const paragraph = paragraphs[i];
                    if (paragraph.length > 100 && paragraph.length < 500) { // Limit paragraph for topic
                        topics.push({ topic: paragraph.substring(0, 100) + "...", content: paragraph });
                    }
                }
            }
            return [...new Map(topics.map(item => [item.topic, item])).values()].slice(0, 20);
        }
        function generateConceptBasedQuestions(concepts, domain, numQuestions) {
            const questions = [];
            if (!concepts || concepts.length === 0) return questions;
            const usedConcepts = new Set();
            const maxQuestions = Math.min(numQuestions, concepts.length);
            for (let i = 0; i < maxQuestions; i++) {
                let conceptIndex;
                if (usedConcepts.size >= concepts.length) break;
                do {
                    conceptIndex = Math.floor(Math.random() * concepts.length);
                } while (usedConcepts.has(conceptIndex));
                usedConcepts.add(conceptIndex);
                const concept = concepts[conceptIndex];
                if (!concept || !concept.term || !concept.description) continue;

                const questionTypes = [generateDefinitionQuestion, generateIdentificationQuestion, generateFunctionQuestion, generateCharacteristicQuestion];
                const questionGenerator = questionTypes[Math.floor(Math.random() * questionTypes.length)];
                const question = questionGenerator(concept, domain);
                if (question) questions.push(question);
            }
            return questions;
        }
        function generateContentBasedQuestions(paragraphs, pages, numQuestions) {
            const questions = [];
            if (!paragraphs || paragraphs.length === 0) return questions;
            const usedParagraphs = new Set();
            const maxQuestions = Math.min(numQuestions, paragraphs.length);
            for (let i = 0; i < maxQuestions; i++) {
                let paragraphIndex;
                if (usedParagraphs.size >= paragraphs.length) break;
                do {
                    paragraphIndex = Math.floor(Math.random() * paragraphs.length);
                } while (usedParagraphs.has(paragraphIndex));
                usedParagraphs.add(paragraphIndex);
                const paragraph = paragraphs[paragraphIndex];
                if (!paragraph) continue;
                let pageNum = findPageForContent(paragraph, pages);
                const question = generateFactualQuestion(paragraph, pageNum);
                if (question) questions.push(question);
            }
            return questions;
        }
        function generateDefinitionQuestion(concept, domain) {
            if (!concept || !concept.term || !concept.description) return null;
            const term = concept.term.slice(0,50); // Truncate term
            const description = concept.description.slice(0,250); // Truncate desc
            let question = `Which of the following best defines ${term}?`.slice(0,300);
            let definition = description.replace(new RegExp(`${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s+(?:is|are|refers to|means|can be defined as)\\s+`, 'i'), '').replace(/\.$/, '');
            if (definition === description) definition = description;
            const incorrectOptions = generateIncorrectDefinitions(definition, domain);
            if (incorrectOptions.length < 3) return null; 
            const options = [definition, ...incorrectOptions.slice(0,3)]; 
            shuffleArray(options);
            const correctIndex = options.indexOf(definition);
            if (correctIndex === -1) return null;
            const answerLetter = String.fromCharCode(65 + correctIndex);
            return { question: question, options: options.map(o => String(o).slice(0,150)), answer: answerLetter };
        }
        function generateIdentificationQuestion(concept, domain) {
            if (!concept || !concept.term || !concept.description) return null;
            const term = concept.term.slice(0,50);
            const description = concept.description.slice(0,250);
            let descriptionForQuestion = description.replace(new RegExp(`${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s+(?:is|are|refers to|means|can be defined as)\\s+`, 'i'), 'It ');
            descriptionForQuestion = descriptionForQuestion.replace(new RegExp(`\\b${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi'), 'it');
            let question = `Which of the following is being described: "${descriptionForQuestion.slice(0,200)}${descriptionForQuestion.length > 200 ? '...' : ''}"`.slice(0,300);
            const incorrectOptions = generateIncorrectTerms(term, domain);
            if (incorrectOptions.length < 3) return null;
            const options = [term, ...incorrectOptions.slice(0,3)];
            shuffleArray(options);
            const correctIndex = options.indexOf(term);
             if (correctIndex === -1) return null;
            const answerLetter = String.fromCharCode(65 + correctIndex);
            return { question: question, options: options.map(o => String(o).slice(0,100)), answer: answerLetter };
        }
        function generateFunctionQuestion(concept, domain) {
             if (!concept || !concept.term || !concept.description) return null;
            if (!['finance', 'science', 'technology'].includes(domain)) return generateDefinitionQuestion(concept, domain);
            const term = concept.term.slice(0,50);
            const description = concept.description.slice(0,250);
            let question = `What is the primary function of ${term}?`.slice(0,300);
            let functionDescription = description; // Default to full description
            if (description.match(/\b(function|purpose|role|used to|serves to)\b/i)) {
                const parts = description.split(/\s+(?:function|purpose|role|used\s+to|serves\s+to)\s+/i);
                if (parts.length > 1) functionDescription = parts[1].replace(/\.$/, '');
            }
            const incorrectOptions = generateIncorrectFunctions(functionDescription, domain);
             if (incorrectOptions.length < 3) return null;
            const options = [functionDescription, ...incorrectOptions.slice(0,3)];
            shuffleArray(options);
            const correctIndex = options.indexOf(functionDescription);
             if (correctIndex === -1) return null;
            const answerLetter = String.fromCharCode(65 + correctIndex);
            return { question: question, options: options.map(o => String(o).slice(0,150)), answer: answerLetter };
        }
        function generateCharacteristicQuestion(concept, domain) {
            if (!concept || !concept.term || !concept.description) return null;
            const term = concept.term.slice(0,50);
            const description = concept.description.slice(0,250);
            let question = `Which of the following is a characteristic of ${term}?`.slice(0,300);
            const correctOption = description;
            const incorrectOptions = generateIncorrectCharacteristics(correctOption, domain);
            if (incorrectOptions.length < 3) return null;
            const options = [correctOption, ...incorrectOptions.slice(0,3)];
            shuffleArray(options);
            const correctIndex = options.indexOf(correctOption);
             if (correctIndex === -1) return null;
            const answerLetter = String.fromCharCode(65 + correctIndex);
            return { question: question, options: options.map(o => String(o).slice(0,150)), answer: answerLetter };
        }
        function generateFactualQuestion(paragraph, pageNum) {
            if (!paragraph) return null;
            const sentences = paragraph.match(/[^.!?]+[.!?]+/g) || [];
            if (sentences.length === 0) return null;
            const factualSentences = sentences.filter(s => s.length > 30 && s.length < 150 && !s.match(/\b(might|may|could|would|should)\b/i) );
            if (factualSentences.length === 0) return null;
            const sentence = factualSentences[Math.floor(Math.random() * factualSentences.length)].slice(0,200); // Truncate sentence
            const keyTerms = findKeyTerms(sentence);
            let question, correctAnswer, incorrectOptions, options, correctIndex, answerLetter;

            if (keyTerms.length > 0) {
                const keyTerm = keyTerms[Math.floor(Math.random() * keyTerms.length)].slice(0,50); // Truncate keyterm
                question = sentence.replace(new RegExp(`\\b${keyTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i'), '_______');
                question = ("Which of the following correctly completes this statement: " + question).slice(0,300);
                correctAnswer = keyTerm;
                incorrectOptions = generateIncorrectAnswers(correctAnswer);
                 if (incorrectOptions.length < 3) return null;
                options = [correctAnswer, ...incorrectOptions.slice(0,3)];
            } else {
                question = `Which of the following statements about page ${pageNum} content is true?`.slice(0,300);
                correctAnswer = sentence;
                incorrectOptions = generateFalseStatements(correctAnswer);
                if (incorrectOptions.length < 3) return null;
                options = [correctAnswer, ...incorrectOptions.slice(0,3)];
            }
            shuffleArray(options);
            correctIndex = options.indexOf(correctAnswer);
            if (correctIndex === -1) return null; 
            answerLetter = String.fromCharCode(65 + correctIndex);
            return { question: question, options: options.map(o => String(o).slice(0,150)), answer: answerLetter };
        }
        function generateOpenQuestion(topicInfo, domain) { 
             if (!topicInfo || !topicInfo.topic) return null; 
             const topic = topicInfo.topic.slice(0,100); // Truncate topic for question
            const openQuestionTemplates = [
                `Analyze the key factors that influence ${topic}...`,
                `Discuss the significance of ${topic}... and its implications.`,
                `Explain how ${topic}... relates to broader concepts in this field.`,
                `Evaluate the effectiveness of approaches related to ${topic}...`,
                `Compare and contrast different perspectives on ${topic}...`,
            ];
            if (domain === 'finance') openQuestionTemplates.push(`Explain how economic changes affect ${topic}...`);
            if (domain === 'science') openQuestionTemplates.push(`Describe evidence for theories about ${topic}...`);
            return openQuestionTemplates[Math.floor(Math.random() * openQuestionTemplates.length)].slice(0,300);
        }
        function findKeyTerms(sentence) { 
            const words = sentence.split(' ');
            const keyTerms = [];
            const commonWords = new Set(['about', 'after', 'again', 'below', 'could', 'every', 'first', 'found', 'great', 'house', 'large', 'learn', 'never', 'other', 'place', 'small', 'study', 'their', 'there', 'these', 'think', 'three', 'water', 'where', 'which', 'world', 'would', 'write', 'the', 'a', 'an', 'is', 'are', 'was', 'were', 'of', 'in', 'on', 'at', 'to', 'for', 'with', 'by', 'from']);
            for (let i = 0; i < words.length; i++) {
                const word = words[i].replace(/[.,;:!?]$/, '');
                if (word.length < 4 || commonWords.has(word.toLowerCase())) continue;
                if (/^[A-Z][a-z]+$/.test(word) || (word.length > 5 && /^[a-z]+$/i.test(word))) {
                    keyTerms.push(word);
                }
            }
            return keyTerms.slice(0,10); // Limit number of key terms
        }
        function generateIncorrectOptionsHelper(baseOptions, count = 3) {
            shuffleArray(baseOptions);
            return baseOptions.slice(0, count).map((opt, idx) => `${opt} (Option ${idx + Math.random().toFixed(2)})`); // Ensure unique enough
        }
        function generateIncorrectDefinitions(correctDefinition, domain) {
            const genericDefinitions = [ "A theoretical concept with limited practical applications.", "A minor technical procedure.", "An outdated approach.", "A specialized technique.", "A conceptual framework lacking support.", "A controversial method." ];
            return generateIncorrectOptionsHelper(genericDefinitions);
        }
        function generateIncorrectTerms(correctTerm, domain) {
            let relatedTermsPool = DOMAIN_KEYWORDS[domain] || Object.values(DOMAIN_KEYWORDS).flat();
            relatedTermsPool = relatedTermsPool.filter(term => term.toLowerCase() !== String(correctTerm).toLowerCase());
            if (relatedTermsPool.length < 3) relatedTermsPool.push("Generic Term Alpha", "Generic Term Beta", "Generic Term Gamma");
            return generateIncorrectOptionsHelper(relatedTermsPool);
        }
        function generateIncorrectFunctions(correctFunction, domain) {
            const genericFunctions = [ "To increase complexity.", "To limit compatibility.", "To prioritize aesthetics over usability.", "To maximize resource consumption.", "To restrict user control.", "To enforce obsolescence."];
            return generateIncorrectOptionsHelper(genericFunctions);
        }
        function generateIncorrectCharacteristics(correctCharacteristic, domain) {
            const genericChars = [ "Contradicts its basic definition.", "Functions independently of related systems.", "Demonstrates perfect efficiency.", "Lacks practical applications.", "Operates on disproven principles.", "Remains unchanged by external factors."];
            return generateIncorrectOptionsHelper(genericChars);
        }
        function generateIncorrectAnswers(correctAnswer) {
            const alternatives = { short: ["primary", "secondary", "critical", "optional"], medium: ["significant", "negligible", "essential", "peripheral"], long: ["comprehensive", "fragmentary", "interdisciplinary", "specialized"] };
            let wordPool = String(correctAnswer).length < 6 ? alternatives.short : (String(correctAnswer).length < 10 ? alternatives.medium : alternatives.long);
            wordPool = wordPool.filter(w => w.toLowerCase() !== String(correctAnswer).toLowerCase());
            if (wordPool.length < 3) wordPool.push("Alternative A", "Alternative B", "Alternative C");
            return generateIncorrectOptionsHelper(wordPool);
         }
        function generateFalseStatements(trueStatement) {
            const genericFalse = [ "The text explicitly contradicts this concept.", "This represents a common misconception.", "This statement directly opposes key principles.", "This conflates two separate ideas.", "This oversimplifies a complex concept."];
            return generateIncorrectOptionsHelper(genericFalse);
        }
        function findPageForContent(content, pages) {
            if (!pages || pages.length === 0) return 1; // Default to page 1 if no pages
            for (let i = 0; i < pages.length; i++) {
                if (pages[i] && pages[i].text && pages[i].text.includes(String(content).substring(0, 50))) return pages[i].pageNum;
            }
            return Math.floor(Math.random() * pages.length) + 1;
        }
        function generateCSVContent(data, headers, includeHeader) {
            let csvContent = "";
            if (includeHeader) csvContent += headers.map(escapeCSV).join(',') + '\r\n';
            if (data) {
                data.forEach(row => {
                    if (row && Array.isArray(row)) { // Ensure row is an array
                        csvContent += row.map(escapeCSV).join(',') + '\r\n';
                    }
                });
            }
            return csvContent;
        }
        function escapeCSV(value) {
            if (value === null || value === undefined) return '';
            value = String(value);
            if (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r')) { // Added \r
                value = value.replace(/"/g, '""').replace(/\r?\n|\r/g, ' '); // Replace newlines with space for Quizizz
                return `"${value}"`;
            }
            return value;
        }
        function updatePreview(data, headers) {
            previewHeader.innerHTML = '';
            previewBody.innerHTML = '';
            if (headers) {
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider';
                    th.textContent = header;
                    previewHeader.appendChild(th);
                });
            }
            if (data) {
                const previewData = data.slice(0, 3);
                previewData.forEach(row => {
                    const tr = document.createElement('tr');
                    if (row && Array.isArray(row)) {
                        row.forEach(cell => {
                            const td = document.createElement('td');
                            td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300';
                            td.textContent = String(cell).length > 30 ? String(cell).substring(0, 30) + '...' : String(cell);
                            tr.appendChild(td);
                        });
                    }
                    previewBody.appendChild(tr);
                });
            }
        }
        function shuffleArray(array) {
            if (!array || !Array.isArray(array)) return [];
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Helper function to show error message
        function showError(message) {
            errorMessage.classList.remove('hidden');
            errorText.textContent = message;
            processingStatus.classList.add('hidden'); // Hide progress if error shown
        }

        // Helper function to reset file input and related UI
        function resetFileInput() {
            selectedFile = null;
            fileInput.value = ''; // Important to clear the actual file input
            uploadIconDefault.classList.remove('hidden');
            uploadIconSelected.classList.add('hidden');
            uploadTextDefault.classList.remove('hidden');
            uploadTextSelected.classList.add('hidden');
            uploadTextSelected.textContent = '';

            questionSettings.classList.add('hidden');
            outputArea.classList.add('hidden');
            previewContainer.classList.add('hidden');
            errorMessage.classList.add('hidden');

            if (downloadLink) {
                downloadLink.href = '#';
                downloadLink.removeAttribute('download');
            }
            csvData = []; // Clear any previous CSV data

            setProcessingState(false); // This will correctly set button state
            updateStatus("", 0); // Clear status text and progress
        }

        // Helper function to set UI for processing state
        function setProcessingState(isProcessing) {
            processButton.disabled = isProcessing;

            if (isProcessing) {
                buttonIconSend.classList.add('hidden');
                buttonIconLoader.classList.remove('hidden');
                buttonText.textContent = 'Processing...';
                errorMessage.classList.add('hidden'); // Hide any previous errors
                processingStatus.classList.remove('hidden');
            } else { // Reverting from processing state (or setting initial state)
                buttonIconSend.classList.remove('hidden');
                buttonIconLoader.classList.add('hidden');
                buttonText.textContent = 'Generate Questions';
                // Keep processingStatus hidden unless explicitly shown on success/error
                // processingStatus.classList.add('hidden'); // Only hide if not showing "Complete!" or "Error"

                // Re-evaluate button enabled state based on selectedFile
                if (selectedFile) {
                    processButton.disabled = false;
                    processButton.classList.remove('bg-gray-400', 'cursor-not-allowed');
                    processButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2', 'focus:ring-blue-500');
                } else {
                    processButton.disabled = true;
                    processButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                    processButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2', 'focus:ring-blue-500');
                }
            }
        }

        // Helper function to update status message and progress bar
        function updateStatus(message, percentComplete) {
            statusText.textContent = message;
            progressBar.style.width = `${percentComplete}%`;
            if (message === "Complete!" || message.toLowerCase().includes("error")) {
                // Don't immediately hide processingStatus if it's a final message
            } else if (percentComplete < 100 && percentComplete > 0) {
                 processingStatus.classList.remove('hidden');
            } else {
                processingStatus.classList.add('hidden');
            }
        }

        // Drag and drop functionality
        uploadAreaLabel.addEventListener('dragover', (event) => {
            event.preventDefault();
            uploadAreaLabel.classList.add('border-blue-500');
        });
        uploadAreaLabel.addEventListener('dragleave', (event) => {
            event.preventDefault();
            uploadAreaLabel.classList.remove('border-blue-500');
        });
        uploadAreaLabel.addEventListener('drop', (event) => {
            event.preventDefault();
            uploadAreaLabel.classList.remove('border-blue-500');
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                const changeEvent = new Event('change', { bubbles: true });
                fileInput.dispatchEvent(changeEvent);
            }
        });

        // Initial setup: ensure button is disabled if no file selected
        setProcessingState(false);

    </script>
</body>
</html>
